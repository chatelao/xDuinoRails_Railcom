# RCN-218: DCC-A – Automatische Anmeldung

**Ausgabe: 27.07.2025**

---

## Inhalt

- [1 Allgemeines](#1-allgemeines)
  - [1.1 Zweck der Norm](#11-zweck-der-norm)
  - [1.2 Anforderungen](#12-anforderungen)
  - [1.3 Kennzeichnung und Erkennung einer DCC-Anlage](#13-kennzeichnung-und-erkennung-einer-dcc-anlage)
  - [1.4 Nachrichtenabsicherung](#14-nachrichtenabsicherung)
  - [1.5 Glossar, Definitionen](#15-glossar-definitionen)
- [2 Genereller Ablauf](#2-genereller-ablauf)
  - [2.1 Vereinzelungsphase](#21-vereinzelungsphase)
  - [2.2 Bekanntmachungsphase](#22-bekanntmachungsphase)
  - [2.3 Registrierung](#23-registrierung)
  - [2.4 Beschleunigtes Einlesen/Schreiben von Decoderparametern](#24-beschleunigtes-einlesenschreiben-von-decoderparametern)
- [3 DCC-Befehle](#3-dcc-befehle)
  - [3.1 Befehlscodierung](#31-befehlscodierung)
  - [3.2 LOGON_ENABLE](#32-logon_enable)
  - [3.3 SELECT](#33-select)
    - [3.3.1 Unterbefehl Read ShortInfo](#331-unterbefehl-read-shortinfo)
    - [3.3.2 Unterbefehl ReadBlock](#332-unterbefehl-readblock)
    - [3.3.3 Unterbefehl WriteBlock](#333-unterbefehl-writeblock)
    - [3.3.4 Unterbefehl Setze Decoder-internen Status](#334-unterbefehl-setze-decoder-internen-status)
  - [3.4 GET_DATA_*](#34-get_data_)
  - [3.5 SET_DATA_*](#35-set_data_)
  - [3.6 LOGON_ASSIGN](#36-logon_assign)
- [4 RailCom-Nachrichten](#4-railcom-nachrichten)
  - [4.1 ID15 - Decoder-Unique (Anmeldung)](#41-id15---decoder-unique-anmeldung)
  - [4.2 ID13 - Decoder-State](#42-id13---decoder-state)
  - [4.3 Datenraumübertragung mittels GET_DATA_*](#43-datenraumübertragung-mittels-get_data_)
- [5 Datenräume](#5-datenräume)
  - [5.1 Datenraum ShortInfo](#51-datenraum-shortinfo)
  - [5.2 Datenraum 0 Extended Capabilities](#52-datenraum-0-extended-capabilities)
  - [5.3 Datenraum 1 SpaceInfo](#53-datenraum-1-spaceinfo)
  - [5.4 Datenraum 2 ShortGUI](#54-datenraum-2-shortgui)
  - [5.5 Datenraum 3 CV-Read](#55-datenraum-3-cv-read)
  - [5.6 Datenraum 4 Icon Zuordnung](#56-datenraum-4-icon-zuordnung)
  - [5.7 Datenraum 5 Langer Name](#57-datenraum-5-langer-name)
  - [5.8 Datenraum 6 Produktinformationen](#58-datenraum-6-produktinformationen)
  - [5.9 Datenraum 7 Fahrzeugspezifischer Datenraum](#59-datenraum-7-fahrzeugspezifischer-datenraum)
  - [5.10 Weitere Datenräume](#510-weitere-datenräume)
- [6 Implementierung in der Zentralen](#6-implementierung-in-der-zentralen)
  - [6.1 Anmeldung](#61-anmeldung)
  - [6.2 Lesen von Decoderparametern](#62-lesen-von-decoderparametern)
  - [6.3 Überprüfung der DCC-A Tauglichkeit einer Modellanlage](#63-überprüfung-der-dcc-a-tauglichkeit-einer-modellanlage)
- [7 Verhalten von Decodern](#7-verhalten-von-decodern)
  - [7.1 Neustart](#71-neustart)
  - [7.2 Backoff](#72-backoff)
- [Anhang A: Verweise auf andere Normen](#anhang-a-verweise-auf-andere-normen)
- [Anhang B: Historie](#anhang-b-historie)
- [Anhang C: Berechnung CRC](#anhang-c-berechnung-crc)
- [Anhang D: Adressen](#anhang-d-adressen)
- [Anhang E: Berechnungsbeispiel für die ZID](#anhang-e-berechnungsbeispiel-für-die-zid)
- [Anhang F: Beispiel zum Beschreiben eines Namensraumes](#anhang-f-beispiel-zum-beschreiben-eines-namensraumes)

---

## 1 Allgemeines

### 1.1 Zweck der Norm

Diese Norm beschreibt DCC-A, ein automatisches Anmeldeverfahren für DCC. Damit wird die Anwenderfreundlichkeit von Modellbahnsteuerungen signifikant erhöht. Bei Anwendung dieser Norm wird der Benutzer bei der Vergabe von Adressen und Zuweisung von Funktionen entlastet. Ziel ist es, z.B. ein Fahrzeug nach dem Aufgleisen sofort mit Namen und allen Eigenschaften im Fahrpult verfügbar zu haben.

Anwendung dieser Norm bietet:

- Super schnelles Anmelden - echtes Plug&Play. Auspacken, aufs Gleis, Loslegen.
- Direkte Verfügbarkeit der Eigenschaften des Decoders / des Fahrzeugs
- Aufwandsarme Implementierung sowohl für Zentralen als auch für Decoder
- Kompatibilität zu vorhandenen Decodern und Zentralen

Diese Norm setzt auf die in den Normen [RCN-211] und [RCN-217] beschriebenen Paketstrukturen für DCC bzw. für RailCom auf.

Für die Implementierungsunterstützung in der Zentrale und dem Decoder stehen Header-Dateien und Beispiele zur Prüfsummenberechnung bei der RailCommunity bereit.

Diese Norm beschreibt nur den Datenaustausch zwischen Decoder und Zentrale, welcher für die Anmeldung und die dringend zur Anmeldung benötigten Daten umfasst. Weiterer Datenaustausch erfolgt dann basierend auf der zugeteilten DCC-Adresse.

### 1.2 Anforderungen

Um diese Norm zu erfüllen, ist es erforderlich, dass alle hier genormten Befehle und Datenstrukturen unterstützt werden. Optionale Bestandteile sind separat gekennzeichnet.

Der korrekte und schnelle Empfang der in dieser Norm definierten Nachrichten ist für den Anmeldevorgang wichtig. Damit dies gewährleistet ist, sind folgende Vorgaben einzuhalten:

- Nachrichtenabsicherung gemäß Kapitel 1.4.
- Nachrichten entsprechend dieser Norm dürfen direkt aufeinander folgen. Ein ev. in anderen Normen definierter Mindestabstand zweier Nachrichten an den gleichen Decoder ist – ausgenommen von SET_DATA_END – nicht vorgesehen.

Bei der Kennzeichnung von Komponenten, welche dieser Norm entsprechen, ist die einheitliche Schreibweise DCC-A zu verwenden.

### 1.3 Kennzeichnung und Erkennung einer DCC-Anlage

Um Decodern beim Einschalten eine schnelle Erkennungsmöglichkeit zu bieten, ob auf der vorhandenen Gleisanlage das Anmeldeverfahren nach DCC-A implementiert ist, werden alle DCC-Nachrichten mit einer Signatur im Form einer besonderen Pulsbreite der ersten Null nach den Präambel-Bits, d.h. dem Paket-Startbit, gekennzeichnet. Zentralen mit aktivem DCC-A erzeugen das DCC-Signal wie folgt:

Eine Null wird symmetrisch mit 100us ±2us pro Halb-Bit erzeugt. Davon abweichend wird die erste Null nach der Präambel, d.h. das Startbit eines DCC-Pakets, ebenfalls symmetrisch mit 114us ± 2us pro Halb-Bit erzeugt.

Ein Decoder erkennt eine DCC-A Anlage, wenn das gesamte Startbit mindestens 20 µs länger als die anderen empfangenen 0-Bits ist.

### 1.4 Nachrichtenabsicherung

Wesentlich für die Übertragungssicherheit ist eine komplette Auswertung des Bittimings der DCC-Kodierung, der Decoder muss beide Flanken des DCC-Signals bei der Auswertung beachten. Nachrichten, die bei der Auswertung Fehler zeigen sind zu verwerfen. Aus Gründen der Harmonisierung mit [S-9.2.1.1] wird bei Nachrichten zusätzlich eine Absicherung mit einer 8-Bit CRC eingeführt. Da es damit zwei Prüfbytes gibt – das per EXOR generierte Prüfbyte nach [RCN-211] und die neu eingeführte CRC-Prüfsumme – werden im Folgenden die Begriffe EXOR-Byte (oder kurz EXOR) und CRC-Byte (oder kurz CRC) verwendet.

Es gelten folgende Regeln:

a) **DCC-Nachrichten:**
DCC-Nachrichten werden immer und generell durch ein abschließendes XOR geschützt. Bei Nachrichten entsprechend dieser Norm, deren erstes Byte 254 ist, wird eine CRC vor dem XOR eingefügt, wenn die Nachricht (ohne jegliche Prüfsumme) 6 oder mehr Bytes einschließlich der Adresse 254 enthält. Nachrichten, deren CRC-Prüfsumme (sofern vorhanden) oder XOR fehlerhaft ist, sind zu verwerfen.

b) **RailCom-Nachrichten:**
Hier wird der Einsatz der CRC bei der jeweiligen Nachricht beschrieben.

c) **Berechnung der CRC:**
Auf der Senderseite wird das gemäß Polynom `x^8 + x^5 + x^4 + 1` über die Nachricht gebildet, beginnend beim ersten Byte der Nachricht, initialisiert auf 0 (bzw. die Nummer des Datenraums, siehe Abschnitt 4.3), nicht invertiert. Empfängerseitig wird die CRC mit dem gleichen Polynom über die gesamte Nachricht inkl. CRC gebildet, das Ergebnis muss 0 sein. Beispiele, Informative Anmerkungen und Algorithmusvorschläge siehe Anhang C: Berechnung CRC.

### 1.5 Glossar, Definitionen

Innerhalb dieser Norm gelten folgende Festlegungen:

- Die Bits eines Bytes werden von 0 bis 7 gezählt. Bit 0 ist das niederwertigste Bit und steht ganz rechts und Bit 7 ist das höchstwertigste und steht ganz links.
- Zwischen den Bits 4 und 3 wird für eine bessere Lesbarkeit ein Strich eingefügt: `7654-3210`.
- Abgesehen von der Beschreibung des Aufbaus der DCC-Pakete im Abschnitt 3 werden die Nullen zwischen den Bytes eines DCC-Paketes, die Synchronbits, das einleitende Byte `1111-1110` und die Prüfbytes `CCCC-CCCC` (CRC) und/oder `PPPP-PPPP` (XOR) nicht dargestellt. Damit sind die DCC-Pakete immer 2 bzw. 3 Bytes länger als der dargestellte Befehl.
- Es wird häufig das ganze Byte dargestellt; Bits ohne Bedeutung im aktuellen Kontext werden mit 'x' gekennzeichnet.
- Folgende Zeichen werden zur Kennzeichnung der Bedeutung eines Bits verwendet:
  - `0`: Bitwert 0
  - `1`: Bitwert 1
  - `A`: Adressbit
  - `a`: Anzahl der zu übertragenen Bytes
  - `B`: Befehlsbit
  - `C`: CRC Prüfbits
  - `c`: Changecount
  - `D`: Datenbits
  - `G`: Adressierungsgruppe
  - `H`: Herstellerkennung entsprechend [S-9.2.2 Appendix A]
  - `M`: Adressierungsmodus
  - `N`: Nummer des Datenraumes
  - `P`: XOR Prüfbits
  - `S`: Session ID (Sitzungsnummer)
  - `U`: Unique ID Teil des Herstellers (32 Bit, Produktkennung + Seriennummer)
  - `V`: Konfigurationsvariablenbits (Adressierung)
  - `x`: Platzhalter für ein Bit, dessen Wert von der Art des Pakets und des Befehls abhängt und an der Stelle nicht näher betrachtet wird.
  - `Z`: ZID = Kennung der Zentrale
- Zusätzlich werden folgende Begriffe festgelegt:
  - **Unique ID:** Die von Hersteller in den Baustein (Decoder/Zentrale) fest programmierte, eineindeutige Kennung, bestehend aus 12 Bit Herstellerkennung und 32 Bit herstellerspezifischer Nummer (z.B. Produktindex und Seriennummer). Sofern eine Eingabe/Darstellung erforderlich ist, soll diese im folgenden Format erfolgen, wobei hier ausnahmsweise jeder Buchstabe für ein Hex Zeichen (Nibble), also jeweils 4 Bit, steht: `HHHUUUUUUuu`. HHH bezeichnet die 12 Bit Herstellerkennung, UUUUUUuu die 32 Bit eindeutige Kennung.
  - **ACK:** Acknowledge entsprechend [RCN-217] in der Codierung `0x0F`.
  - **DID:** Die Unique ID eines Decoders.
  - **ZID:** Die Kennung der Zentrale. Hierbei handelt es sich um einen 16 Bit Wert, welcher durch einen Hash der Herstellerkennung und der Unique ID der Zentrale berechnet wird.
  - **Session ID:** Eine Variable, welche die aktuelle Betriebsphase kennzeichnet.
  - **Backoff:** Sollte ein Decoder nach einer versuchten Anmeldung keine Bestätigung erhalten, so beantwortet dieser eine (variable) Anzahl von LOGON_ENABLE-Nachrichten nicht mehr.
  - **Konventionelle Adresse:** Bezeichnet die Adresse, die sich unter Auswertung der CVs 1, 17, 18 19 und 29 ergibt.
  - **DCC-A Adresse:** Ist die während des Betriebes mit DCC-A zugewiesene Adresse.
  - **CRC:** Die CRC (Cyclic Redundancy Check) ist eine Prüfsumme, die entsprechend Anhang C berechnet wird.
  - **XDCC:** Eine Erweiterung des DCC-Formats nach NMRA Norm [S-9.2.1.1].

---

## 2 Genereller Ablauf

Die automatische Anmeldung unterteilt sich in folgende Hauptphasen:

- **Vereinzelungsphase:** Ermittlung der Decoder und Lösung von Zugriffskonflikten.
- **Bekanntmachungsphase:** Austausch von Informationen zwischen Zentrale und Decoder.
- **Registrierung:** Der Decoder wird an der Zentrale registriert.

### 2.1 Vereinzelungsphase

Die Zentrale sendet `LOGON_ENABLE`-Aufforderungen. Decoder antworten mit ihrer Unique ID. Bei Kollisionen erfolgt eine Vereinzelung mittels dynamischem Backoff.

### 2.2 Bekanntmachungsphase

Die Zentrale bestätigt die Anmeldung und spricht den Decoder über seine DID an (`SELECT` / `GET_DATA_*`). Der Decoder übermittelt seine wichtigsten Steuerparameter.

### 2.3 Registrierung

Die Zentrale weist dem Decoder eine Fahrzeugadresse zu (`LOGON_ASSIGN`). Die zugewiesene Adresse gilt für alle Fahrzeugbefehle. Der Decoder speichert ZID, Session-ID und die temporäre DCC-A Adresse.

### 2.4 Beschleunigtes Einlesen/Schreiben von Decoderparametern

Informationen im Decoder sind in Datenräume unterteilt. Ein kompletter Datenraum kann mit `SELECT` / `GET_DATA_*` ausgelesen bzw. mit `SELECT` / `SET_DATA_*` beschrieben werden.

---

## 3 DCC-Befehle

Alle DCC-Befehle zur automatischen Anmeldung beginnen mit `1111-1110`.

### 3.1 Befehlscodierung

| Befehlsbyte | Länge | Ausw. | RailCom-Antwort | Bedeutung |
|---|---|---|---|---|
| `0000-0000` | 1 | Hist. | Data Stream | `GET_DATA_START` |
| `0000-0001` | 1 | Hist. | Data Stream | `GET_DATA_CONT` |
| `0000-0010` | 10 | Hist. | ACK | `SET_DATA` |
| `0000-0011` | 10 | Hist. | ACK | `SET_DATA_END` |
| `1101-HHHH` | 7-12 | DID | ACK | `SELECT` |
| `1110-HHHH` | 8 | DID | ID13, Stat | `LOGON_ASSIGN` |
| `1111-11xx` | 4 | Backoff | ID15, Anmeldung | `LOGON_ENABLE` |

### 3.2 LOGON_ENABLE

Format: `1111-11GG ZZZZ-ZZZZ ZZZZ-ZZZZ SSSS-SSSS`

- `GG`: Adressierungsgruppe (ALL, LOCO, ACC, NOW)
- `ZZZZ-ZZZZ`: ZID (Zentralenkennung)
- `SSSS-SSSS`: Session ID

Anmeldeaufforderung. Decoder antworten mit ihrer Unique ID oder warten bei Backoff.

### 3.3 SELECT

Format: `1101-HHHH ... UUUU-UUUU BBBB-BBBB (Parameter)`

- `HHHH...`: 12 Bit Herstellerkennung
- `UUUU...`: 32 Bit eindeutige Kennung
- `BBBB-BBBB`: Unterbefehl

| Unterbefehl | Bedeutung |
|---|---|
| `1111-1111` | Read ShortInfo |
| `1111-1110` | Read Block |
| `1111-1100` | Write Block |
| `1111-1011` | Setze Decoder-internen Status |

#### 3.3.1 Unterbefehl Read ShortInfo

Liest die Kurzinformation (Datenraum ShortInfo).

#### 3.3.2 Unterbefehl ReadBlock

Liest einen kompletten Datenraum blockweise.

#### 3.3.3 Unterbefehl WriteBlock

Schreibt einen kompletten Datenraum blockweise.

#### 3.3.4 Unterbefehl Setze Decoder-internen Status

Setzt interne Statusflags, z.B. löscht Changeflags.

### 3.4 GET_DATA_*

- `GET_DATA_START: 0000-0000`
- `GET_DATA_CONT: 0000-0001`

Dienen zum Abholen von Daten nach einem `SELECT` mit `ReadBlock`.

### 3.5 SET_DATA_*

- `SET_DATA: 0000-0010 {Daten}` (max 11 Datenbytes)
- `SET_DATA_END: 0000-0011`

Dienen zum Senden von Daten an den Decoder.

### 3.6 LOGON_ASSIGN

Format: `1110-HHHH ... uuuu-uuuu BBAA-AAAA AAAA-AAAA`

- `HHHH...`, `uuuu...`: Unique ID
- `BB`: 11=temporär, 10=permanent
- `AAAA...`: Zugewiesene Adresse

Registriert den Decoder und weist eine Adresse zu.

---

## 4 RailCom-Nachrichten

RailCom-Antworten bündeln Kanal 1 und 2 zu einer 48-Bit-Nachricht:
`ID(4) | EXT1(4) | EXT2(4) | EXT3(4) | DATA(32)`

### 4.1 ID15 - Decoder-Unique (Anmeldung)

Antwort auf `LOGON_ENABLE`. Enthält die 44-Bit Unique ID des Decoders.

### 4.2 ID13 - Decoder-State

Antwort auf `LOGON_ASSIGN`. Enthält Changeflags, Changecount und Protokollfähigkeiten.

| Changeflags (Bit) | Bedeutung |
|---|---|
| F0 | ZID geändert |
| F1 | Firmware geändert |
| F2 | Fahrverhalten geändert |
| F3 | Funktionszuordnung geändert |
| F4 | GUI-Daten geändert |
| F5 | Mehrfachtraktion war aktiviert |
| F7 | Konventionelle Adresse/Name geändert |

### 4.3 Datenraumübertragung mittels GET_DATA_*

Daten werden in Blöcken übertragen: `HEADER [DATEN] CRC`.
- `HEADER`: 1 Byte, enthält Blocktyp und Länge.
- `DATEN`: max. 31 Bytes.
- `CRC`: 1 Byte.

---

## 5 Datenräume

| Nr. | Inhalt |
|---|---|
| -- | ShortInfo (feste Größe) |
| 0 | Extended Capabilities |
| 1 | SpaceInfo (Verfügbarkeit der Datenräume) |
| 2 | ShortGUI (Name, Bild, Funktionen) |
| 3 | CV-Block |
| 4 | Icon Zuordnung |
| 5 | Langer Name und Beschreibung |
| 6 | Produktinformationen |
| 7 | Fahrzeugspezifischer Datenraum |

### 5.1 Datenraum ShortInfo

6 Bytes, Sonderformat. Enthält Wunschadresse, höchste Funktionsnummer und grundlegende Protokollfähigkeiten.

### 5.2 Datenraum 0 Extended Capabilities

Variable Größe. Enthält weitere Protokollfähigkeiten.

### 5.3 Datenraum 1 SpaceInfo

Variable Größe. Bitfeld über verfügbare Datenräume.

### 5.4 Datenraum 2 ShortGUI

Variable Größe. Enthält Name, Bildindex, Prinzipsymbol und Funktionsauskunft.

### 5.5 Datenraum 3 CV-Read

Variable Größe. Enthält angefragte CV-Werte.

### 5.6 Datenraum 4 Icon Zuordnung

Variable Größe. Ordnet Funktionsnummern Icons zu.

### 5.7 Datenraum 5 Langer Name

Variable Größe. Enthält langen Namen und Beschreibung als UTF-8 Strings.

### 5.8 Datenraum 6 Produktinformationen

Variable Größe. Enthält Hersteller, Produktname, HW/SW-Version als UTF-8 Strings.

### 5.9 Datenraum 7 Fahrzeugspezifischer Datenraum

Variable Größe. Enthält Hersteller, Produktnummer und Bild-URL des Fahrzeugs.

### 5.10 Weitere Datenräume

Reserviert für zukünftige Erweiterungen.

---

## 6 Implementierung in der Zentralen

### 6.1 Anmeldung

Beschreibt den Ablauf der Anmeldung und Vereinzelung aus Sicht der Zentrale.

### 6.2 Lesen von Decoderparametern

Beschreibt verschiedene Methoden zum Lesen von Daten (XDCC, DCC-A, POM/XPOM).

### 6.3 Überprüfung der DCC-A Tauglichkeit einer Modellanlage

Beschreibt ein Verfahren, um störende Decoder zu erkennen, bevor DCC-A aktiviert wird.

---

## 7 Verhalten von Decodern

### 7.1 Neustart

Beschreibt, wie ein Decoder nach einem Neustart (Kontaktproblem, Aufgleisen) reagiert.

### 7.2 Backoff

Beschreibt den Backoff-Mechanismus zur Kollisionsvermeidung bei der Anmeldung.

---

## Anhang A: Verweise auf andere Normen

Listet normative und informative Verweise.

## Anhang B: Historie

Änderungshistorie des Dokuments.

## Anhang C: Berechnung CRC

Details zur CRC-Berechnung mit Polynom `x^8 + x^5 + x^4 + 1` und Codebeispielen.

## Anhang D: Adressen

Abbildung von DCC-Adressen auf ein 14-Bit-Format.

## Anhang E: Berechnungsbeispiel für die ZID

Empfohlenes Verfahren zur Berechnung der 16-Bit Zentralen-ID.

## Anhang F: Beispiel zum Beschreiben eines Namensraumes

Detailliertes Beispiel für einen `WriteBlock`-Vorgang.
